# 多模板系统架构分析

## 一、当前系统架构分析

### 1.1 当前模板匹配逻辑

**位置**：`backend/apps/products/template_serializers.py` 的 `get_product_template()` 函数

**匹配规则**：
```python
1. 优先匹配：子分类模板（product.subcategory → template）
2. 其次匹配：分类模板（product.category → template，且template.subcategory为空）
3. 无匹配：返回None
```

**特点**：
- ✅ 自动匹配，无需手动选择
- ⚠️ 一个分类只能有一个模板（取order最小的）
- ❌ 产品无法手动指定模板
- ❌ 不支持同一分类下多个模板选择

---

### 1.2 当前数据模型

**Product模型**：
```python
class Product:
    category = ForeignKey(Category)      # 必须
    subcategory = ForeignKey(SubCategory) # 可选
    # ❌ 没有template字段
```

**ProductTemplate模型**：
```python
class ProductTemplate:
    category = ForeignKey(Category)      # 可选
    subcategory = ForeignKey(SubCategory) # 可选
    # 一个模板可以关联一个分类或子分类
```

**问题**：
- 产品无法直接关联模板
- 只能通过分类/子分类间接匹配
- 一个分类下多个模板时，只能选择order最小的

---

## 二、需求分析：多模板支持

### 2.1 使用场景

**场景1：同一分类有多个模板**
```
分类：工业铝型材
  ├─ 模板A：标准T-Slot模板
  ├─ 模板B：重型T-Slot模板
  └─ 模板C：轻型T-Slot模板

产品1 → 使用模板A
产品2 → 使用模板B
产品3 → 使用模板C
```

**场景2：特殊产品需要特殊模板**
```
产品A属于分类X，但需要使用分类Y的模板
```

**场景3：产品手动选择模板**
```
管理员在创建产品时，手动选择使用哪个模板
```

---

## 三、解决方案设计

### 方案A：产品直接关联模板（推荐）

**核心思路**：
- 产品添加`template`字段，直接关联模板
- 支持手动选择模板
- 如果没有选择，则自动匹配（保持向后兼容）

**优点**：
- ✅ 最灵活，支持所有场景
- ✅ 向后兼容（没有指定模板时自动匹配）
- ✅ 管理员可以精确控制

**缺点**：
- ⚠️ 需要修改Product模型
- ⚠️ 需要添加选择模板的UI

---

### 方案B：增强自动匹配规则

**核心思路**：
- 保持自动匹配
- 通过模板的`order`字段选择（order最小）
- 或者通过模板的`name`匹配产品名称

**优点**：
- ✅ 无需修改Product模型
- ✅ 保持自动化

**缺点**：
- ❌ 不够灵活
- ❌ 无法精确控制某个产品使用哪个模板

---

### 方案C：混合方案（推荐）

**核心思路**：
- 产品添加`template`字段（可选）
- 匹配优先级：
  1. **最高**：产品直接关联的模板（product.template）
  2. **次高**：子分类模板
  3. **第三**：分类模板
  4. **最低**：无模板

**优点**：
- ✅ 最灵活
- ✅ 向后兼容
- ✅ 支持自动匹配和手动选择

---

## 四、推荐方案：方案C（混合方案）

### 4.1 数据模型改动

#### 修改Product模型

```python
class Product(models.Model):
    # ... 现有字段 ...
    
    # ⭐新增：直接关联模板（可选）
    template = models.ForeignKey(
        ProductTemplate, 
        on_delete=models.SET_NULL, 
        null=True, 
        blank=True,
        verbose_name='关联模板',
        help_text='如果指定，优先使用此模板；否则自动匹配分类/子分类模板'
    )
    
    # ⭐新增：是否使用模板内容（可选，用于控制是否使用模板）
    use_template = models.BooleanField(
        '使用模板内容',
        default=True,
        help_text='如果为False，则不使用模板，只使用产品自定义数据'
    )
```

#### ProductTemplate模型保持不变

可以支持：
- 一个分类可以有多个模板
- 一个子分类可以有多个模板
- 模板可以只关联分类，也可以只关联子分类

---

### 4.2 模板匹配逻辑改动

#### 修改 `get_product_template()` 函数

```python
def get_product_template(product):
    """获取产品匹配的模板"""
    
    # 优先级1：产品直接关联的模板（最高优先级）
    if product.template and product.template.is_active:
        return product.template
    
    # 如果产品设置了不使用模板，返回None
    if hasattr(product, 'use_template') and not product.use_template:
        return None
    
    # 优先级2：子分类模板
    if product.subcategory:
        template = ProductTemplate.objects.filter(
            subcategory=product.subcategory,
            category__isnull=True,  # 只匹配子分类模板
            is_active=True
        ).order_by('order').first()
        if template:
            return template
    
    # 优先级3：分类模板
    if product.category:
        template = ProductTemplate.objects.filter(
            category=product.category,
            subcategory__isnull=True,  # 只匹配分类模板（不包含子分类模板）
            is_active=True
        ).order_by('order').first()
        if template:
            return template
    
    return None
```

---

### 4.3 序列化器改动

#### ProductDetailSerializer 保持不变

因为已经在 `to_representation()` 中调用了 `get_product_template()`，只需要修改该函数即可。

---

### 4.4 后台管理改动

#### 修改ProductAdmin

```python
@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    # ... 现有配置 ...
    
    fields = [
        'category', 'subcategory',
        'template',  # ⭐新增：模板选择
        'use_template',  # ⭐新增：是否使用模板
        'name', 'description', 
        # ... 其他字段
    ]
    
    # 添加模板选择的帮助文本
    help_texts = {
        'template': '如果指定模板，将优先使用此模板；否则自动匹配分类/子分类模板',
        'use_template': '如果关闭，则不使用任何模板，只使用产品自定义数据'
    }
```

---

### 4.5 前端改动

#### 前端无需改动

因为：
- 前端只调用产品详情API
- API返回的数据已经包含了合并后的模板数据
- 前端不需要知道模板选择的逻辑

---

## 五、实现步骤

### 步骤1：修改Product模型

```python
# 在Product模型中添加
template = models.ForeignKey(ProductTemplate, ...)
use_template = models.BooleanField(default=True)
```

### 步骤2：创建数据库迁移

```bash
python manage.py makemigrations products --name add_product_template_field
python manage.py migrate
```

### 步骤3：修改模板匹配逻辑

```python
# 修改 get_product_template() 函数
# 添加产品直接关联模板的优先级
```

### 步骤4：更新后台管理

```python
# 在ProductAdmin中添加template和use_template字段
# 添加选择模板的UI
```

### 步骤5：更新序列化器

```python
# 确保ProductSerializer包含template字段
# 确保匹配逻辑正确
```

---

## 六、模板选择策略

### 6.1 自动匹配（默认）

**场景**：产品没有指定模板

**匹配规则**：
1. 子分类模板（如果产品有子分类）
2. 分类模板（如果产品有分类）

**适用**：
- 批量创建产品
- 同类产品使用相同模板
- 简化操作

### 6.2 手动选择（精确控制）

**场景**：产品指定了模板

**方式**：
- 在产品编辑页面选择模板
- 优先级最高

**适用**：
- 特殊产品需要特殊模板
- 跨分类使用模板
- 精确控制

### 6.3 禁用模板（完全自定义）

**场景**：产品设置了 `use_template=False`

**效果**：
- 不使用任何模板
- 只使用产品自定义数据

**适用**：
- 完全定制化产品
- 测试产品
- 特殊需求

---

## 七、多个模板的管理策略

### 7.1 模板命名建议

```
模板命名规范：
- 分类名 + 模板类型
- 例如：
  - "T-Slot铝型材-标准模板"
  - "T-Slot铝型材-重型模板"
  - "LED型材-标准模板"
  - "LED型材-迷你模板"
```

### 7.2 模板分类组织

**方式1：按分类组织**
```
分类：工业铝型材
  ├─ T-Slot标准模板
  ├─ T-Slot重型模板
  └─ T-Slot轻型模板
```

**方式2：按功能组织**
```
模板名称：
  ├─ 通用铝型材模板（关联多个分类）
  ├─ 标准模板（适用于大多数产品）
  └─ 定制模板（特殊产品）
```

### 7.3 模板优先级

**同一分类多个模板时的选择**：
- 如果产品指定了模板 → 使用指定模板
- 如果自动匹配 → 使用`order`最小的模板
- 管理员可以通过调整`order`控制默认模板

---

## 八、前后端改动清单

### 后端改动

#### 1. 模型修改
- [ ] Product模型添加`template`字段
- [ ] Product模型添加`use_template`字段
- [ ] 创建数据库迁移

#### 2. 逻辑修改
- [ ] 修改`get_product_template()`函数
  - 添加产品直接关联模板的优先级
  - 添加`use_template`判断
- [ ] 修改`merge_template_data()`函数
  - 确保正确处理`use_template=False`的情况

#### 3. 序列化器修改
- [ ] ProductSerializer添加`template`字段
- [ ] ProductDetailSerializer确保包含template信息

#### 4. 后台管理修改
- [ ] ProductAdmin添加template字段
- [ ] ProductAdmin添加use_template字段
- [ ] 添加模板选择的帮助文本
- [ ] 优化模板选择UI（显示模板名称和关联分类）

#### 5. API修改
- [ ] 确保产品API返回template信息（可选）
- [ ] 模板API保持不变

---

### 前端改动

#### 1. 接口定义（无需改动）
- ✅ 前端只调用产品详情API
- ✅ API返回的数据已经合并了模板数据
- ✅ 前端不需要知道模板选择逻辑

#### 2. 显示优化（可选）
- [ ] 可以在产品详情页显示使用的模板名称（调试用）
- [ ] 可以显示哪些数据来自模板（可选）

---

## 九、使用示例

### 示例1：自动匹配（默认）

```
产品：HG112 150x30 T-Slot Profile
分类：工业铝型材
子分类：T-Slot铝型材

系统自动：
1. 查找子分类"T-Slot铝型材"的模板
2. 找到模板："T-Slot铝型材-标准模板"
3. 自动应用该模板
```

### 示例2：手动选择模板

```
产品：HG112 150x30 T-Slot Profile
分类：工业铝型材
子分类：T-Slot铝型材
模板：手动选择 → "T-Slot铝型材-重型模板"

系统：
1. 优先使用产品指定的模板
2. 忽略自动匹配
3. 应用"T-Slot铝型材-重型模板"
```

### 示例3：跨分类使用模板

```
产品：Custom LED Profile
分类：装饰铝型材
模板：手动选择 → "工业铝型材-标准模板"

系统：
1. 使用指定的模板（即使分类不同）
2. 应用"工业铝型材-标准模板"的内容
```

### 示例4：禁用模板

```
产品：Fully Custom Product
分类：工业铝型材
模板：无
use_template：False

系统：
1. 不使用任何模板
2. 只使用产品自定义数据
```

---

## 十、实施建议

### 阶段1：基础支持（1-2天）

1. ✅ 修改Product模型，添加template字段
2. ✅ 创建数据库迁移
3. ✅ 修改模板匹配逻辑
4. ✅ 更新后台管理界面

### 阶段2：测试验证（1天）

1. ✅ 测试自动匹配（向后兼容）
2. ✅ 测试手动选择模板
3. ✅ 测试禁用模板
4. ✅ 测试多个模板场景

### 阶段3：优化完善（可选）

1. ⚠️ 模板选择UI优化
2. ⚠️ 模板预览功能
3. ⚠️ 批量应用模板功能

---

## 十一、总结

### 核心改动

1. **Product模型**：添加`template`和`use_template`字段
2. **匹配逻辑**：支持产品直接关联模板（最高优先级）
3. **后台管理**：添加模板选择UI
4. **前端**：无需改动（API自动处理）

### 优势

- ✅ 灵活：支持自动匹配和手动选择
- ✅ 向后兼容：不影响现有产品
- ✅ 易于管理：后台可视化选择
- ✅ 精确控制：产品可以精确指定模板

### 适用场景

- ✅ 同一分类多个模板
- ✅ 特殊产品需要特殊模板
- ✅ 跨分类使用模板
- ✅ 完全自定义产品

